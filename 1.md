# 作業一

學號：51115113 

課程：系統程式設計  

題目：遞迴函式實作

---

## 題目說明

本題要求實現一個遞迴函式 `sigma`，計算從 1 到 n 的連加總和。

---

## 解題策略

- 利用遞迴將問題分解為：\( \Sigma(n) = n + \Sigma(n-1) \)
- 當 \( n \leq 1 \) 時結束遞迴，回傳 \( n \)
- 使用遞迴思維表達問題拆解，程式碼與數學式對應明確

---

## 程式碼實作

```cpp
#include <iostream>
using namespace std;

int sigma(int n) {
    if (n < 0)
        throw "n < 0";
    else if (n <= 1)
        return n;
    return n + sigma(n - 1);
}

int main() {
    int result = sigma(3);
    cout << result << '\n';
    return 0;
}
```

---

## 效能分析

- **時間複雜度**：\( O(n) \)，每次遞迴減少 \( n \) 一次直到 0 為止
- **空間複雜度**：\( O(n) \)，系統堆疊會為每層遞迴儲存狀態

---

## 測試與驗證

| 測試案例 | 輸入參數 \( n \) | 預期輸出 | 實際輸出 |
|-----------|------------------|------------|------------|
| 測試一    | 0                | 0          | 0          |
| 測試二    | 1                | 1          | 1          |
| 測試三    | 3                | 6          | 6          |
| 測試四    | 5                | 15         | 15         |
| 測試五    | -1               | 拋出例外   | 拋出例外   |

### 編譯與執行指令：
```
g++ -std=c++17 -o sigma sigma.cpp
./sigma
```

---

## 結論

- 程式能正確計算 \( \Sigma(n) = 1 + 2 + ... + n \)
- 負數情況能成功拋出例外
- 測試案例涵蓋邊界值與例外狀況，驗證程式正確性

---

## 申論與開發報告

### 為何選擇遞迴？

- 遞迴語法清楚，邏輯直觀
- 對應數學公式簡潔，程式碼易讀：
  ```cpp
  int sigma(int n) {
      if (n < 0)
          throw "n < 0";
      else if (n <= 1)
          return n;
      return n + sigma(n - 1);
  }
  ```
- 每次遞迴等同解一個子問題，最終再一層層返回解答

### 遞迴的缺點

- 遞迴會使用系統堆疊空間，當 \( n \) 過大可能造成 Stack Overflow
- 若要處理極大 \( n \)，建議改用迴圈（iterative）解法

---

透過本練習可以深入理解遞迴的結構與執行流程，對日後撰寫複雜遞迴邏輯奠定基礎。
