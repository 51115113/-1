# 41143263

遞迴作業一

## 題目一：Sigma 遞迴總和

### 解題策略
本題是計算 1 加到 n 的總和，可用遞迴函式拆解為：
$$
\Sigma(n) = n + \Sigma(n-1)
$$
當 $n \leq 1$ 時作為遞迴結束條件。

### 程式碼實作
```cpp
#include <iostream>
using namespace std;

int sigma(int n) {
    if (n < 0) throw "n < 0";
    if (n <= 1) return n;
    return n + sigma(n - 1);
}

int main() {
    cout << "sigma(3): " << sigma(3) << endl;
    return 0;
}
```

### 效能分析
- 時間複雜度：$O(n)$
- 空間複雜度：$O(n)$（系統堆疊）

### 測試案例
| 測試案例 | 輸入 n | 預期輸出 | 實際輸出 |
|----------|--------|-----------|-----------|
| 測試一   | 0      | 0         | 0         |
| 測試二   | 1      | 1         | 1         |
| 測試三   | 3      | 6         | 6         |
| 測試四   | 5      | 15        | 15        |
| 測試五   | -1     | 拋出異常 | 拋出異常 |

---

## 題目二：Ackermann 函數

### 解題策略
Ackermann 是高度遞迴函數，會快速產生巨大值，定義如下：
$$
A(m, n) =
\begin{cases}
  n+1 & \text{if } m = 0 \\
  A(m-1, 1) & \text{if } m>0 \land n=0 \\
  A(m-1, A(m, n-1)) & \text{if } m>0 \land n>0
\end{cases}
$$

### 程式碼實作
```cpp
#include <iostream>
using namespace std;

int ackermann(int m, int n) {
    if (m == 0) return n + 1;
    if (n == 0) return ackermann(m - 1, 1);
    return ackermann(m - 1, ackermann(m, n - 1));
}

int main() {
    cout << "ackermann(2, 3): " << ackermann(2, 3) << endl;
    return 0;
}
```

### 效能分析
- 時間複雜度：超指數等級（極高）
- 空間複雜度：$O(m + n)$ 遞迴堆疊深度

### 測試案例
| 測試案例 | 輸入 $(m,n)$ | 預期輸出 |
|----------|--------------|-----------|
| 測試一   | (0, 0)       | 1         |
| 測試二   | (1, 0)       | 2         |
| 測試三   | (1, 2)       | 4         |
| 測試四   | (2, 3)       | 9         |
